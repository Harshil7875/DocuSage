# client/client.py

import requests
import sys
import os
import argparse
import json
from datetime import datetime
from pathlib import Path
import mimetypes

# ANSI color codes for terminal output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_colored(text, color):
    """Print text in specified color"""
    print(f"{color}{text}{Colors.ENDC}")

def print_error(message):
    """Print error message in red"""
    print_colored(f"Error: {message}", Colors.RED)

def print_success(message):
    """Print success message in green"""
    print_colored(message, Colors.GREEN)

def print_info(message):
    """Print info message in blue"""
    print_colored(message, Colors.BLUE)

def format_file_size(size_bytes):
    """Format file size in human-readable format"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} TB"

def get_mime_type(file_path):
    """Determine the appropriate MIME type for the file"""
    mime_type, _ = mimetypes.guess_type(file_path)
    if mime_type:
        return mime_type
    # Fallback for common types
    if file_path.lower().endswith('.pdf'):
        return 'application/pdf'
    return 'text/plain'

def save_history(file_path, summary, metadata, output_format):
    """Save summary to history file"""
    history_file = Path.home() / '.docusage_history.json'
    
    try:
        if history_file.exists():
            with open(history_file, 'r') as f:
                history = json.load(f)
        else:
            history = []
            
        history.append({
            'file_path': str(file_path),
            'summary': summary,
            'metadata': metadata,
            'timestamp': datetime.now().isoformat(),
            'format': output_format
        })
        
        # Keep only last 50 entries
        history = history[-50:]
        
        with open(history_file, 'w') as f:
            json.dump(history, f, indent=2)
            
    except Exception as e:
        print_colored(f"Warning: Could not save to history: {e}", Colors.YELLOW)

def save_summary(summary, file_path, output_format, metadata=None):
    """Save summary to file in specified format"""
    base_name = Path(file_path).stem
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    if output_format == 'txt':
        output_file = f"{base_name}_summary_{timestamp}.txt"
        with open(output_file, 'w') as f:
            f.write(summary)
    
    elif output_format == 'md':
        output_file = f"{base_name}_summary_{timestamp}.md"
        with open(output_file, 'w') as f:
            f.write(f"# Summary of {Path(file_path).name}\n\n")
            f.write(f"*Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n\n")
            f.write(summary)
            f.write("\n\n---\n*Generated by DocuSage*")
    
    elif output_format == 'json':
        output_file = f"{base_name}_summary_{timestamp}.json"
        data = {
            'original_file': str(file_path),
            'summary': summary,
            'metadata': metadata,
            'timestamp': datetime.now().isoformat()
        }
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    return output_file

def main():
    parser = argparse.ArgumentParser(
        description='DocuSage CLI - Advanced Document Summarization',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('server', help='Server IP address or hostname')
    parser.add_argument('file', help='Path to the document file')
    parser.add_argument('--port', '-p', default='8000', help='Server port (default: 8000)')
    parser.add_argument('--length', '-l', choices=['brief', 'standard', 'detailed'], 
                       default='standard', help='Summary length (default: standard)')
    parser.add_argument('--language', '-L', choices=['en', 'es', 'fr', 'de', 'ja', 'zh'], 
                       default='en', help='Summary language (default: en)')
    parser.add_argument('--output', '-o', choices=['console', 'txt', 'md', 'json'], 
                       default='console', help='Output format (default: console)')
    parser.add_argument('--save', '-s', action='store_true', 
                       help='Save summary to file (in addition to console output)')
    parser.add_argument('--quiet', '-q', action='store_true', 
                       help='Minimal output')
    parser.add_argument('--verbose', '-v', action='store_true', 
                       help='Verbose output')
    parser.add_argument('--health', action='store_true', 
                       help='Check server health and exit')
    
    args = parser.parse_args()
    
    # Health check mode
    if args.health:
        try:
            response = requests.get(f"http://{args.server}:{args.port}/health", timeout=5)
            if response.ok:
                data = response.json()
                print_success(f"Server is {data['status']}")
                print_info(f"Ollama is {data['ollama']}")
                sys.exit(0)
            else:
                print_error("Server is not responding properly")
                sys.exit(1)
        except Exception as e:
            print_error(f"Cannot connect to server: {e}")
            sys.exit(1)
    
    # Check if file exists
    if not os.path.isfile(args.file):
        print_error(f"File not found: {args.file}")
        sys.exit(1)
    
    # Get file info
    file_size = os.path.getsize(args.file)
    file_name = os.path.basename(args.file)
    mime_type = get_mime_type(args.file)
    
    # Check file size
    if file_size > 10 * 1024 * 1024:
        print_error("File is too large. Maximum size is 10MB.")
        sys.exit(1)
    
    if not args.quiet:
        print_info(f"Processing: {file_name}")
        print_info(f"File size: {format_file_size(file_size)}")
        print_info(f"MIME type: {mime_type}")
        print_info(f"Server: {args.server}:{args.port}")
        print_info(f"Options: {args.length} summary in {args.language}")
        print()
    
    # Build URL
    url = f"http://{args.server}:{args.port}/summarize"
    
    # Send request
    try:
        with open(args.file, "rb") as f:
            files = {"file": (file_name, f, mime_type)}
            data = {
                "length": args.length,
                "language": args.language
            }
            
            if args.verbose:
                print_info("Sending request...")
            
            response = requests.post(url, files=files, data=data, timeout=120)
            response.raise_for_status()
            
    except requests.exceptions.Timeout:
        print_error("Request timed out (120s). The file might be too large.")
        sys.exit(1)
    except requests.exceptions.ConnectionError:
        print_error(f"Cannot connect to server at {args.server}:{args.port}")
        print_info("Make sure the server is running and accessible.")
        sys.exit(1)
    except requests.exceptions.HTTPError as e:
        print_error(f"HTTP error: {e}")
        try:
            error_data = response.json()
            print_error(f"Server message: {error_data.get('detail', 'Unknown error')}")
        except:
            pass
        sys.exit(1)
    except requests.exceptions.RequestException as e:
        print_error(f"Request failed: {e}")
        sys.exit(1)
    
    # Process response
    try:
        result = response.json()
        summary = result.get("summary", "[no summary returned]")
        metadata = result.get("metadata", {})
    except ValueError:
        print_error("Invalid response format from server")
        sys.exit(1)
    
    # Display results
    if args.output == 'console' or args.save:
        if not args.quiet:
            print_success("Summary generated successfully!")
            print(f"\n{Colors.HEADER}{Colors.BOLD}=== Summary ==={Colors.ENDC}\n")
        print(summary)
    
    # Save to file if requested
    if args.save or args.output != 'console':
        output_format = args.output if args.output != 'console' else 'txt'
        output_file = save_summary(summary, args.file, output_format, metadata)
        if not args.quiet:
            print_success(f"\nSaved to: {output_file}")
    
    # Save to history
    save_history(args.file, summary, metadata, args.output)
    
    # Show metadata if verbose
    if args.verbose and metadata:
        print(f"\n{Colors.YELLOW}=== Metadata ==={Colors.ENDC}")
        print(f"Original size: {format_file_size(metadata.get('original_size', 0))}")
        print(f"Text length: {metadata.get('text_length', 0)} characters")
        print(f"Summary length: {metadata.get('summary_length', 0)} characters")
        print(f"Language: {metadata.get('language', 'unknown')}")
        print(f"Length option: {metadata.get('length_option', 'unknown')}")
        print(f"Generated at: {metadata.get('timestamp', 'unknown')}")

if __name__ == "__main__":
    main()